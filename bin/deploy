#!/bin/bash
#
#  Deploy a standardized, standalone, lsst-build sandbox
#

SCRIPT_DIR=$(cd "$(dirname "$0")"; pwd)
# shellcheck disable=SC1090
source "${SCRIPT_DIR}/../etc/settings.cfg.sh"

LSST_EUPS_VERSION=${LSST_EUPS_VERSION:-2.1.5}
LSST_EUPS_GITREV=${LSST_EUPS_GITREV:-""}
LSST_EUPS_GITREPO=${LSST_EUPS_GITREPO:-https://github.com/RobertLuptonTheGood/eups.git}
# force Python 3
LSST_PYTHON_VERSION=3
LSST_MINICONDA_VERSION=${LSST_MINICONDA_VERSION:-4.5.12}
LSST_MINICONDA_BASE_URL=${LSST_MINICONDA_BASE_URL:-https://repo.continuum.io/miniconda}
LSST_CONDA_CHANNELS=${LSST_CONDA_CHANNELS:-""}
LSST_GIT_VERSION=${LSST_GIT_VERSION:-2.18.0}
LSST_LFS_VERSION=${LSST_LFS_VERSION:-2.4.2}
LSST_BUILD_GITREV=${LSST_BUILD_GITREV:-master}
LSST_BUILD_GITREPO=${LSST_BUILD_GITREPO:-https://github.com/lsst/lsst_build.git}
LSST_SCIPIPECENV_GITREPO=${LSST_SCIPIPECENV_GITREPO:-https://github.com/lsst/scipipe_conda_env.git}
# this git ref controls which set of conda packages are used to initialize the
# the default conda env defined in scipipe_conda_env git package (RFC-553).
LSST_SPLENV_REF=${LSST_SPLENV_REF:-1172c30}

set -e

print_error() {
  >&2 echo -e "$@"
}

fail() {
  local code=${2:-1}
  [[ -n $1 ]] && print_error "$1"
  # shellcheck disable=SC2086
  exit $code
}

usage() {
  if [[ ! -z "$1" ]]; then
    print_error "$0: $1"
  fi

  # note that heredocs are prefixed with tab chars
  fail "$(cat <<-EOF

		Usage: $0 [-2] [-3] [-b] [-h] [-e] [-r]

		Specific options:
        -b          use bleeding edge conda packages
        -e REF      github reference in scipipe_conda_env (tag or SHA1)
        -r BRANCH   github branch in scipipe_conda_env
        -3          use Python 3 (default)
        -2          use Python 2 (no longer supported -- fatal error)
        -h          show this message

		EOF
  )"
}

config_curl() {
  # Prefer system curl; user-installed ones sometimes behave oddly
  if [[ -x /usr/bin/curl ]]; then
    CURL=${CURL:-/usr/bin/curl}
  else
    CURL=${CURL:-curl}
  fi

  # disable curl progress meter unless running under a tty -- this is intended to
  # reduce the amount of console output when running under CI
  CURL_OPTS=('-#')
  if [[ ! -t 1 ]]; then
    CURL_OPTS=('-sS')
  fi

  # curl will exit 0 on 404 without the fail flag
  CURL_OPTS+=('--fail')
}

fetch_repos.yaml() {
  local ref=${1:-master}
  local output_file=${2:-$REPOSFILE}
  local repo=${3:-$REPOSFILE_REPO}

  local baseurl="https://raw.githubusercontent.com/${repo}/${ref}"

  $CURL "${CURL_OPTS[@]}" \
    -L \
    "${baseurl}/etc/repos.yaml" \
    -o "$output_file"
}

parse_args() {
  local OPTIND
  local opt

  # We are intentionally not using gnu `getopt` due to portability concerns.
  # Sadly, this means no long options without a massive amount of boilerplate.
  while getopts "23bher" opt; do
    case "$opt" in
    b)
      BLEED_DEPLOY=true
      ;;
    3)
      # noop
      ;;
    2)
      fail 'Python 2.x is no longer supported.'
      ;;
    h)
      usage
      ;;
    e)
      shift;
      ENVREF=$1
      ;;
    r)
      shift;
      ENVBREF=$1
      ;;
    *)
      usage "Unknown option: ${opt}"
      ;;
    esac
  done
  shift $((OPTIND-1))
}

#
# test to see if script is being sourced or executed. Note that this function
# will work correctly when the source is being piped to a shell. `Ie., cat
# newinstall.sh | bash -s`
#
# See: https://stackoverflow.com/a/12396228
#
am_I_sourced() {
  if [ "${FUNCNAME[1]}" = source ]; then
    return 0
  else
    return 1
  fi
}

get_branch_tip_hash() {
    reftip=`git ls-remote https://github.com/lsst/scipipe_conda_env.git ${ENVBREF} | cut -c1-7`
    if [[ $reftip == '' ]]; then
      echo ":::- Branch ${ENVBREF} invalid!"
      exit
    else
      echo "::: Found new environment reference ${reftip} !"
    fi
}

fixnames() {
  FIXED_ENVREF=${ENVREF//[.\/]/-}
  FIXED_ENVBREF=${ENVBREF//[.\/]/-}
}

main() {
  config_curl

  BLEED_DEPLOY=false

  ENVREF=""
  ENVBREF=""

  parse_args "$@"
  fixnames

  mkdir -p "${LSSTSW}"/{sources,build,var/run,var/log,lfs,distserver/production,etc,env}

  export PATH="${LSSTSW}/lfs/bin:${PATH}"
  export PATH="${LSSTSW}/bin:${PATH}"

  local pyver_prefix=$LSST_PYTHON_VERSION
  local miniconda_version=$LSST_MINICONDA_VERSION

  local deploy_mode=packages
  if [[ $BLEED_DEPLOY == true ]]; then
    deploy_mode=bleed
  fi

  case $(uname -s) in
    Linux*)
      local ana_platform='Linux-x86_64'
      local pkg_postfix='linux-64'
      ;;
    Darwin*)
      local ana_platform='MacOSX-x86_64'
      local pkg_postfix='osx-64'
      ;;
    *)
      fail "Cannot install miniconda: unsupported platform $(uname -s)"
      ;;
  esac

  # If -r is provided, -e is ignored
  if [[ $FIXED_ENVBREF != '' ]]; then
    # get latest branch SHA1 and assign it to LSST_SPLENV_REF
    get_branch_tip_hash
    LSST_SPLENV_REF="$reftip"
    # Defining environment name based on branch and SHA1 from the tip of the branch
    LSST_CONDA_ENV_NAME="scipipe-env-${FIXED_ENVBREF}.${LSST_SPLENV_REF}"
  elif [[ $ENVREF != '' ]]; then
    LSST_SPLENV_REF="${ENVREF}"
    # Defining environment name based on the provided SHA1
    LSST_CONDA_ENV_NAME="scipipe-env-${FIXED_ENVREF}"
  fi
  # the folder where to store locally the environment yaml
  REF_FOLDER_NAME=${LSST_SPLENV_REF//[.\/]/-}

  local conda_packages
  conda_packages="conda${pyver_prefix}_${deploy_mode}-${pkg_postfix}.yml"

  cd "$LSSTSW"
  # conda environment reference
  local env_file="${LSSTSW}/env/${FIXED_ENVBREF}/${REF_FOLDER_NAME}/${conda_packages}"
  local env_url="https://raw.githubusercontent.com/lsst/scipipe_conda_env/${LSST_SPLENV_REF}/etc/"

  echo "::: conda environment file: ${env_file}"

  cd env
  if [ -e "${env_file}" ]; then
    echo "::: conda environment already present"
  else
    if [[ $FIXED_ENVBREF != '' ]]; then
      # if a branch is provided, store the environment yaml inside the corresponding subfolder
      mkdir -p "${FIXED_ENVBREF}"
      cd "${FIXED_ENVBREF}"
    fi
    mkdir -p "${REF_FOLDER_NAME}"
    $CURL "${CURL_OPTS[@]}" -# -L \
       "${env_url}/${conda_packages}" \
       --output "${REF_FOLDER_NAME}/${conda_packages}"
  fi

  cd "$LSSTSW"

  fetch_repos.yaml 'master'

  # install miniconda
  miniconda_path="${LSSTSW}/miniconda"
  miniconda_lock="${miniconda_path}/.deployed"
  test -f "$miniconda_lock" || (
    miniconda_file_name="Miniconda${pyver_prefix}"
    miniconda_file_name+="-${miniconda_version}-${ana_platform}.sh"

    echo "::: Deploying ${miniconda_file_name}"

    cd sources
    $CURL "${CURL_OPTS[@]}" -# -L \
      -O "${LSST_MINICONDA_BASE_URL}/${miniconda_file_name}"

    rm -rf "$miniconda_path"
    bash "$miniconda_file_name" -b -p "$miniconda_path"

    touch "$miniconda_lock"
  )

  # intentionally outside of a lockfile subshell
  export PATH="$LSSTSW/miniconda/bin:$PATH"

  (
    # configure alt conda channel(s)
    if [[ -n $LSST_CONDA_CHANNELS ]]; then
      # remove any previously configured non-default channels
      # XXX allowed to fail
      conda config --remove-key channels || true

      for c in $LSST_CONDA_CHANNELS; do
        conda config --add channels "$c"
      done

      # remove the default channels
      conda config --remove channels defaults

      conda config --show
    fi
  )

  # cleanup orphaned lock file
  local old_miniconda_pkgs_lock="${LSSTSW}/miniconda/.packages.deployed"
  [[ -e $old_miniconda_pkgs_lock ]] && rm "$old_miniconda_pkgs_lock"

  (
    # Install packages on which the stack is known to depend

    # conda may leave behind lock files from an uncompleted package
    # installation attempt.  These need to be cleaned up before [re]attempting
    # to install packages.
    conda clean --lock

    ARGS=()
    ARGS+=('env' 'update')
    ARGS+=('--name' "$LSST_CONDA_ENV_NAME")

    # disable the conda install progress bar when not attached to a tty. Eg.,
    # when running under CI
    if [[ ! -t 1 ]]; then
      ARGS+=("--quiet")
    fi

    ARGS+=("--file" "$env_file")

    conda "${ARGS[@]}"
  )

  # intentionally outside of a lockfile subshell
  # shellcheck disable=SC1091
  echo "Activate environment ${LSST_CONDA_ENV_NAME}"
  source activate "${LSST_CONDA_ENV_NAME}"

  # report packages in the current conda env
  #
  # note that `conda list -e`, which is the current format being used for the
  # canoncial env files, doesn't seem to list pip installed packages.  The the
  # "newer" yaml env file format from `conda env export` does include pip/pypi
  # packages.
  conda env export

  test -f "${LSSTSW}/lfs/.git.deployed" || ( # git
    if hash git 2>/dev/null; then
      GITVERNUM=$(git --version | cut -d\  -f 3)
      # shellcheck disable=SC2183 disable=SC2046
      GITVER=$(printf "%02d-%02d-%02d\\n" $(echo "$GITVERNUM" | cut -d. -f1-3 | tr . ' '))
    fi

    if [[ $GITVER < "01-09-00" ]]; then
      echo "::: Deploying git"
      cd sources
      GIT_BASE_URL="https://www.kernel.org/pub/software/scm/git"
      $CURL "${CURL_OPTS[@]}" -L \
        -O "${GIT_BASE_URL}/git-${LSST_GIT_VERSION}.tar.gz"
      $CURL "${CURL_OPTS[@]}" -L \
        -O "${GIT_BASE_URL}/git-manpages-${LSST_GIT_VERSION}.tar.gz"
      tar xzf "git-${LSST_GIT_VERSION}.tar.gz"
      cd "git-${LSST_GIT_VERSION}"
      ./configure --prefix="${LSSTSW}/lfs"
      make -j4
      make install
      man_dir="${LSSTSW}/lfs/share/man"
      mkdir -p "$man_dir"
      cd "$man_dir"
      tar xzf "${LSSTSW}/sources/git-manpages-${LSST_GIT_VERSION}.tar.gz"
      (cd "$LSSTSW" && git config push.default current)
    else
      echo "::: Using installed git"
    fi
    touch "${LSSTSW}/lfs/.git.deployed"
  )

  test -f "${LSSTSW}/lfs/.git-lfs.deployed" || (
    echo "::: Deploying git-lfs"

    case $(uname -s) in
      Linux*)  lfs_platform="linux-amd64" ;;
      Darwin*) lfs_platform="darwin-amd64" ;;
      *)
        fail "Cannot install git-lfs: unsupported platform $(uname -s)"
        ;;
    esac

    cd sources
    LFS_BASE_URL="https://github.com/github/git-lfs/releases/download"
    LFS_ARCHIVE="git-lfs-${lfs_platform}-${LSST_LFS_VERSION}.tar.gz"
    $CURL "${CURL_OPTS[@]}" -L \
      -O "${LFS_BASE_URL}/v${LSST_LFS_VERSION}/${LFS_ARCHIVE}"

    tar xzf "$LFS_ARCHIVE"
    mkdir -p "${LSSTSW}/lfs/bin"
    cp "git-lfs-${LSST_LFS_VERSION}/git-lfs" "${LSSTSW}/lfs/bin/"
    cd "$LSSTSW"
    touch "${LSSTSW}/lfs/.git-lfs.deployed"
  )

  # backwards compatibility if EUPS wasn't installed to a versioned directory
  test -f "${LSSTSW}/eups/.deployed" && ( # EUPS
    echo "::: Moving old EUPS to eups/legacy"
    mv "${LSSTSW}/eups" "${LSSTSW}/eups-tmp"
    mkdir -p "${LSSTSW}/eups"
    mv "${LSSTSW}/eups-tmp" "${LSSTSW}/eups/legacy"
    ln -s legacy "${LSSTSW}/eups/current"
  )

  # if a LSST_EUPS_GITREV is set, use that as the version dir name
  if [[ -n $LSST_EUPS_GITREV ]]; then
    LSST_EUPS_VERSION=$LSST_EUPS_GITREV
  fi

  test -f "${LSSTSW}/eups/${LSST_EUPS_VERSION}/.deployed" || ( # EUPS
    echo "::: Deploying eups ${LSST_EUPS_VERSION}"
    if [[ -e "${LSSTSW}/eups/${LSST_EUPS_VERSION}" ]]; then
      chmod -R +w "${LSSTSW}/eups/${LSST_EUPS_VERSION}"
      rm -rf "${LSSTSW}/eups/${LSST_EUPS_VERSION}"
    fi

    cd sources
    if [[ -n $LSST_EUPS_GITREV ]]; then
      git clone "$LSST_EUPS_GITREPO" eups
      cd eups
      git checkout "$LSST_EUPS_GITREV"
    else
      $CURL "${CURL_OPTS[@]}" -L \
        -o "eups-${LSST_EUPS_VERSION}.tar.gz" \
        "https://github.com/RobertLuptonTheGood/eups/archive/${LSST_EUPS_VERSION}.tar.gz"
      tar xzf "eups-${LSST_EUPS_VERSION}.tar.gz"
      cd "eups-${LSST_EUPS_VERSION}"
    fi

    ./configure \
      --prefix="${LSSTSW}/eups/${LSST_EUPS_VERSION}" \
      --with-python="${LSSTSW}/miniconda/bin/python" \
      --with-eups="${LSSTSW}/stack"
    make
    make install
    touch "${LSSTSW}/eups/${LSST_EUPS_VERSION}/.deployed"
  )

  if [[ "$(readlink "${LSSTSW}/eups/current")" != "$LSST_EUPS_VERSION" ]]; then
    echo "::: Making eups ${LSST_EUPS_VERSION} the default"
    rm -f "${LSSTSW}/eups/current"
    ln -s "${LSST_EUPS_VERSION}" "${LSSTSW}/eups/current"
  fi

  test -f "${LSSTSW}/stack/.deployed" || ( # Adjust the stack config
    echo "::: Deploying manifest.remap"
    cd stack/site
    ln -sf ../../etc/manifest.remap
    touch "${LSSTSW}/stack/.deployed"
  )

  test -f "${LSSTSW}/versiondb/.deployed" || ( # Clone the version database
    echo "::: Deploying versiondb"
    rm -rf versiondb
    git clone "$VERSIONDB_REPO" versiondb

    git config -f versiondb/.git/config user.name "LSST DATA Management"
    git config -f versiondb/.git/config user.email "dm-devel@lists.lsst.org"
    git config -f versiondb/.git/config push.default current
    touch "${LSSTSW}/versiondb/.deployed"
  )

  # Clone lsst_build
  if [[ ! -f "${LSSTSW}/lsst_build/.deployed" ]]; then
    (
      echo "::: Deploying lsst_build"
      rm -rf lsst_build
      git clone "$LSST_BUILD_GITREPO" -b "$LSST_BUILD_GITREV" lsst_build
      (cd lsst_build && git config push.default current)
      touch "${LSSTSW}/lsst_build/.deployed"
    )
  else
    (
      echo "::: Updating lsst_build"
      cd lsst_build
      git fetch -fup origin "$LSST_BUILD_GITREV"
      # attempt to determine if this is a branch name or a commit id. If it is
      # a branch name, we need to reset to the commit id in the origin repo.
      # Otherwise, if the branch already exists in the clone, the local HEAD
      # will be used.
      if ! commit=$(
        git rev-parse \
          --verify \
          --quiet \
          "origin/${LSST_BUILD_GITREV}"
        ); then
        commit=$LSST_BUILD_GITREV
      fi
      git reset --hard "$commit"
    )
  fi

  echo "Done. Run the following:"
  echo

  if [[ $SHELL =~ bash$ ]]; then
    echo "    . ${LSSTSW}/bin/setup.sh"
  elif [[ $SHELL =~ csh$ ]]; then # Supports tcsh
    echo "    . ${LSSTSW}/bin/setup.csh"
  elif [[ $SHELL =~ zsh$ ]]; then
    echo "    . ${LSSTSW}/bin/setup.sh"
  else
    echo "    The setup script in ${LSSTSW}/bin most appropriate for ${SHELL}"
    echo "    (Warning: ${SHELL} is an unsupported shell)"
  fi

  echo
  echo "to begin using it."
}

#
# support being sourced as a lib or executed
#
if ! am_I_sourced; then
  main "$@"
fi

# vim: tabstop=2 shiftwidth=2 expandtab
